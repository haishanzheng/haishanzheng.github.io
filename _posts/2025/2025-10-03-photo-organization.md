---
title:  "一种整理大量照片的方法"
date:   2025-10-03 09:17:22 +0800
---

## 背景

家庭一年新增一万张照片，苹果华为小米多个平台，多部手机多个PAD和其他人分享的，工作、生活、截图、收藏、电子化文档，我不知道你们是怎么管的，有好的方法告诉我。

15年前我写过 [有了相机你还需要：使用Picasa管理照片，使用数码相框看照片](/2010/04/29/photo-management.html) ，已经过时了，Picasa已经停止服务了。所以在整理照片这块，最重要的是，要可以抵挡时间的攻击。

## 照片到底是什么？？？

因为我拍照技术一般，所以我忽略了摄影这个话题，从实用性来看，我认为照片实际上是生活的索引，按写程序的人来说，它们是人生时间轴上打的Event Tracking。

我们对时间的感知是对数型的，随着年龄增长，记忆力衰退，大脑的神经元在面对重复的日常刺激时，不会像全量保存的大语言模型那样增加权重，而是进行“压缩存储”，就像数据去重一样，只是简单地在已有记忆上引用+1。甚至在睡眠时，大脑还会做“磁盘整理”，执行重复数据删除。一旦误删，还可能产生幻觉。

对数运算后导致你会认为很多事情仿佛就发生在昨日，然后感慨时间怎么过得这么快！这个时候，你就需要照片来矫正时间轴。

黑镜S07E05，一个由生成式人工智能驱动的虚拟人，剧透提醒！剧透提醒！！剧透提醒！！！它引导男主从一张普通的照片出发，逐步通过技术手段进行锐化、提高清晰度，重建现场细节。随着神经元突触的模拟链接，更多的照片被接入，零散的记忆片段逐渐拼合成完整的画面。最终，那些尘封已久的记忆被唤醒，一个看似不起眼、当时被忽略的瞬间浮出水面，却揭开了一个令人唏嘘的重要线索。

那么，末日来临，有个“诺亚方舟”可以让你上船，但是你只有十分钟时间准备，只能带一个小东西，你要带什么？

![](/images/2025/twd-1.png)

行尸走肉的瑞克也选择拿走了全家福。“末日准备者”会为各种可能的灾难做准备，包括自然灾害、核战争、超级火山爆发、太阳风暴、磁极逆转、小行星撞地球、人工智能机器人暴乱等。他们会储备食物、水、药品等物资，建造能够抵御各种攻击的避难所，如地下掩体、堡垒等，还会学习各种生存技能，如种植、狩猎、医疗急救等。

我没有准备那么多，我成功将几个T的图片视频压缩成只有14GB，一个U盘即可带走。至于末日还有没有USB口可以插？

当然，照片和视频这个第三代后可能就没有意义了，所以也不需要可以保留太久的方法。

## 手机里的照片怎么处理

**不愿意折腾的，建议直接用云服务。**云服务不一定靠谱，有各种安全问题，比如以前的某某网盘随机看到陌生人照片，被拿去人工智能学习等等，但是它丢失概率不高。

微信里面传图片是会触发某些检查的，网盘里的文件，一旦被分享，某些检查也会启动。但是你很难知道，这个度在哪，某国产流式文档编辑工具就传说有检查个人文件的例子，让你文件莫名其妙丢失掉。

万一误报了呢？所以我建议还是本地要有一个备份。手机是随时会丢掉或者掉在地上导致无法访问所有照片的，所以也要定期传输到电脑里。云服务可能会有备份，有部分整理的能力，有人脸识别的能力，但是本地，配合生成式人工智能的代码能力，也可以玩一些个性化的内容。比如统计哪天拍照最多，下雨天跟拍照数量的关系等等等。

将手机照片传输到电脑有各种方法，以Android为例，使用MTP或者PTP协议，均会带来一个问题，列出DCIM/Camera速度非常慢，如果照片很多的话。

苹果手机在底层的照片保存上是严格遵守落后的DCF（Design rule for Camera File system）规则的，通常是100APPLE目录下面很多个8+3的文件，就是一个目录不超过1万个文件。而Android不严格遵守这个，会放在DCIM/Camera里，不区分子目录，文件名通常会包括拍摄时间，如果照片很多，这个目录很大，在资源管理器里打开速度非常慢。

**所以我会定期把DCIM/Camera做个整理，按年度，建立年的子目录，把当年的所有文件手动移动过去，以解决这个问题。**

如果你不依赖落后的MPT、PTP协议，那这步可以不做。

## 照片梳理原则

前面提到过，我们每个人都要面对“时间的攻击”。你正在使用的软件，可能会因为供应链风险而随时消失。用得越顺手，一旦要迁移，就会越痛苦。

但无论技术如何迭代，**最稳定、最不会背叛你的存储方式，始终是最基础的文件夹**。

如果你玩过数据治理，应该知道会有各种ODS、DWD、DWS名词，你可以把方法论往照片整理上套。数据治理就是，先把所有数据整合在一起，保留一份原始存档。接着进行清洗、去重、标准化，把原始数据转换为可用数据，再在上面进行主题或者业务逻辑的识别、汇总、聚合，最终是为了具体的应用。

### 原始层

原始层是不做更改的，Immutable Copy。

原始层是从各个不同来源过来的照片，我通常会这样命名，**“照片/郑海山/xiaomi19promax/2025”。如果是以年为单位，可以有个临时目录，等收集到超过一年了，再统一移动到正式目录，就不动了。**如果你产生的图片量非常大，可以再分季度或者月份。

这中间照片和视频分开不同的目录。因为照片的信息比比视频大，视频可能可以抛弃，但是照片是要保护的。

**这一阶段初始可能会有重复文件删除的需求，因为如果你历史上都没有整理过，可能文件会比较混乱，这时候你可以应用一些查找重复文件的软件，比如我常用的dupeGuru、AllDup等，识别到原先到处乱放的照片。一旦你遵守了某个行为方式，未来这个功能就不需要了。**

### 再往上一层就是主题层

以上是物理层的存储方式。再往上是逻辑层，这层可以保存在当前使用的软件里，也可以在目录结构里面直接体现。比如“2025/2025-10-06 家里博饼”，不要弄太多，弄太多可能坚持不下去。工作类的照片就整理出去，这里说的更多的是生活类的。**尽量不要整理照片，不要给照片添加标签**，给自己懒惰找个借口，“随着技术的进步，算力的平权，未来会有各种方法可以让我进行多模态识别整理。”

### 应用层

应用为王。

整理后，除了是完整照片的大库以外，还需要有日常可以访问的入口或方式。如果只依赖文件夹目录效率较低，这时候可以安装一些管理工具来快速检索和浏览。

应用程序的比如开源的digiKam，Web端的比如开源的PhotoPrism，可以使用人工智能自动标记和分类，按标签、地点、时间、分辨率、颜色、相机属性等组合过滤照片，也可以给照片整理相册。但是要记住，你在上面耕耘得越多，未来切换越麻烦，差不多即可。

也可以直接请AI写代码帮你做些查找分析类的操作的小脚本。

还可以整理出一些相册，放到 [搞IT的，先把自己家IT好吧——全屋智能](http://127.0.0.1:4000/2025/01/26/smart-home.html) 里面忘记提到的挂墙相册里。

### 有效性验证

磁盘是不可靠的，必须保存多份，除了遵守3-2-1原则，还要定期使用一个程序来读每张照片，如果遇到读取时间超过几ns，就得考虑换磁盘了。

## 末日准备

最后，就是所谓的“末日准备”。既然真到末日，也没必要把一切都原封不动地保存下来，能“看个影儿”就够了。**为了让这些照片更容易带走，我对图片做了压缩处理，把体积控制在一定容量以内。至于视频，则是按时间间隔抽取关键帧，拼接成一张大图，既方便快速浏览，也大大减少了存储空间和拷贝所需的时间。**

我以前写过 [为什么我认为所有搞IT的都应该懂编程](/2019/12/20/why-all-iter-should-learn-programming.html)，也不算数了。现在使用生成式人工智能，你几分钟就可以使用程序把你的照片整理好。按照上面的逻辑，我请AI帮忙写了一段代码，很快就压缩好了。

请AI写代码，就请个高级一点的AI，牛吹得大一点，反正都是随便写的提示词。。。

![](/images/2025/dream-bigger.gif)

## 源代码分享

```text
### Role（角色）

你是一名资深的Python程序员，你和Guido van Rossum是好朋友，你今天刚和Anders Hejlsberg
喝完咖啡就来到工作室来写代码。你拒绝了微软年薪一千万美元的工作。你精通图像与视频处理。
你的代码严格遵循 PEP8 规范，采用强类型注解，函数划分清晰，不写冗长函数。你习惯将逻辑
拆解为独立函数而非类。你擅长错误和异常处理。你参考的代码都是午夜时分提交的。

### Input（输入条件）

程序接收以下输入：

- 一个包含图片的目录名（例如：D:/照片们）
- 一个压缩到目标的目录名（例如：E:/压缩后的照片们/）

### Task（任务）

请编写一个Python程序，完成以下功能：

- 图片压缩
    - 遍历指定目录及子目录，统计文件扩展名分布。
    - 自动识别出现次数最多的图片扩展名，并仅处理这些扩展名的文件。
    - 对图片进行等比例压缩，宽高均不超过 800px，保持元数据。
    - 压缩后的图片输出到与目标目录里，并保存原始目录结构。
- 视频截图与拼接
    - 对目录中的视频文件进行处理。
    - 每个视频平均截取 4 帧画面，并拼接为 2x2 的大图。
    - 输出大图宽高不超过 1600px。
    - 若文件不是视频或无法读取，应有超时机制，避免程序阻塞。

### Constraints（约束条件）

- 定义“魔术数字”为常量。
- 支持包含中文字符的目录路径。
- 输出时提供进度信息与剩余时间预估，缓解用户焦虑。
- 不写冗余注释，代码应自解释。

### Style（风格）

- 函数化设计，保持简洁。
- 错误处理健壮，避免长时间阻塞。
- 输出规范化进度信息。

### Output（输出格式）

直接输出完整、可运行的 Python 代码（带必要的导入和入口函数）。

```
